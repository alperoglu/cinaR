final.peaks <- cp.filtered.annotated[cp.filtered.annotated$distanceToTSS <= TSS.threshold,]
View(entrez2gene)
View(final.peaks)
final.peaks
# filter distance to TSS
final.peaks <- cp.filtered.annotated[abs(cp.filtered.annotated$distanceToTSS) <= TSS.threshold,]
View(final.peaks)
final.peaks
View(final.peaks)
final.peaks
autosomal.genes.only = F
final.peaks$geneStrand
final.peaks$geneId
final.peaks
cp <- final.peaks
View(cp)
cp@seqnames
View(cp.filtered)
cp.filtered
dim(cp.filtered)
dim(cp.filtered.annotated)
length(cp.filtered.annotated)
# annotate the peaks to the closest TSS
cp.filtered.annotation <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
a <- cbind(cp.filtered.annotated, cp.filtered)
View(a)
annotatePeaks <-
function(cp, reference.genome, show.annotation.pie = F){
require(ChIPseeker)
require(GenomicRanges)
bed <- as.data.frame(do.call(rbind, strsplit(rownames(cp), "_", fixed = T)))
colnames(bed) <- c("CHR", "Start", "End")
bed.GRanges <- GRanges(bed)
if (is.null(reference.genome)){
warning("'reference.genome' is not set, therefore hg38 will be used!")
}
if(reference.genome == "hg38" | is.null(reference.genome)){
require("TxDb.Hsapiens.UCSC.hg38.knownGene")
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
} else if (reference.genome == "hg19"){
require(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else if (reference.genome == "mm10"){
require(TxDb.Mmusculus.UCSC.mm10.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
} else {
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# annotate peaks
annoPeaks <- annotatePeak(bed.GRanges, TxDb = txdb)
if(show.annotation.pie){
plotAnnoPie(annoPeaks)
}
annoPeaks.anno <- annoPeaks@anno
entrezids <- unique(annoPeaks.anno$geneId)
require(annotables)
if(reference.genome == "hg38"){
genome <- grch38
} else if (reference.genome == "hg19"){
genome <- grch37
} else if (reference.genome == "mm10"){
genome <- grcm38
} else { # safe than sorry!
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# entrez to gene name mapping
entrez2gene <- subset(genome, genome$entrez %in% entrezids, select = c(entrez, symbol))
# Match to each annotation dataframe
m <- match(annoPeaks.anno$geneId, entrez2gene$entrez)
annoPeaks.anno$gene_name <- entrez2gene$symbol[m]
return(cbind(annoPeaks.anno, cp))
}
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
View(cp.filtered.annotated)
# filter distance to TSS
final.peaks <- cp.filtered.annotated[abs(cp.filtered.annotated$distanceToTSS) <= TSS.threshold,]
View(final.peaks)
View(final.peaks)
require(edgeR)
final.peaks <- cp
# filter distance to TSS
final.peaks <- cp.filtered.annotated[abs(cp.filtered.annotated$distanceToTSS) <= TSS.threshold,]
cp <- final.peaks
DGEList(counts = cp)
View(cp)
cp.metaless <- cp[,16:ncol(cp)]
View(cp.metaless)
DGEList(counts = cp.metaless)
cp.meta <- cp[,1:15]
View(cp.meta)
contrasts <- c(rep(1,11), (2,11))
contrasts <- c(rep(1,11), (2,11))
contrasts <- c(rep(1,11), rep(2,11))
# Calculate normalization factors for library sizes with TMM
y <- calcNormFactors(y, method = "TMM")
require(edgeR)
y <- DGEList(counts = cp.metaless)
# Calculate normalization factors for library sizes with TMM
y <- calcNormFactors(y, method = "TMM")
# Add intercept term for multiple comparisons
design <- model.matrix(~ 0 + contrasts)
View(design)
rownames(design) <- colnames(count.matrix)
rownames(design) <- colnames(cp.metaless)
View(design)
View(design)
# Estimate dispersion for genes with Bayesian Shrinkage
y <- estimateDisp(y,design)
# Estimate dispersion for genes with Bayesian Shrinkage
print(">> Estimating dispersion...")
# Estimate dispersion for genes with Bayesian Shrinkage
cat(">> Estimating dispersion...")
# Fit the model
fit.glm <- glmQLFit(y,design)
View(fit.glm)
contrasts <- c(rep(1,5), rep(2,6), rep(3,7), rep(4,4))
# Add intercept term for multiple comparisons
design <- model.matrix(~ 0 + contrasts)
View(design)
# Add intercept term for multiple comparisons
design <- model.matrix(~ 0 + as.character(contrasts))
View(design)
contrasts <- c(rep("Healthy", 11), rep("Patient", 11))
# Add intercept term for multiple comparisons
design <- model.matrix(~ 0 + as.character(contrasts))
View(design)
rownames(design) <- colnames(cp.metaless)
View(design)
# Add intercept term for multiple comparisons
design <- model.matrix(~ 0 + contrasts)
rownames(design) <- colnames(cp.metaless)
View(design)
contrasts
unique(contrasts)
colnames(design) <- unique(contrasts) # may create some bugs, but keep it for now.
View(design)
y <- estimateDisp(y,design)
# Fit the model
cat(">> Fitting GLM")
# Fit the model
cat(">> Fitting GLM...")
# Create contrasts for comparison!
contrasts <- makeContrasts(
levels = fit.glm$design
)
fit.glm$design
fit.glm$design
fit.glm$design[1]
fit.glm$design[2]
colnames(design)
combn(colnames(design))
combn(colnames(design), m = 2)
choose(5,2)
combn(letters[1:4], 2)
(m <- combn(10, 5, min))   # minimum value in each combination
mm <- combn(15, 6, function(x) matrix(x, 2, 3))
stopifnot(round(choose(10, 5)) == length(m),
c(2,3, round(choose(15, 6))) == dim(mm))
mm
letters
combn(letters[1:4], 2)
c("Healthy", "Mild", "Severe")
a <- c("Healthy", "Mild", "Severe")
combn(a)
combn(a, 2)
# Create contrasts for comparison!
contrasts <- makeContrasts(
combs <- combn(colnames(design), 2)
levels = fit.glm$design
)
# Create contrasts for comparison!
contrasts <- makeContrasts(
combs <- combn(colnames(design), 2)
levels = fit.glm$design
)
combs <- combn(colnames(design), 2)
View(combs)
combs <- combn(colnames(design), 2)
contrasts <- c(rep("Healthy", 8), rep("Mild", 8), rep("Severe", 6))
# Add intercept term for multiple comparisons
design <- model.matrix(~ 0 + contrasts)
rownames(design) <- colnames(cp.metaless)
colnames(design) <- unique(contrasts) # may create weird bugs, but keep it for now.
View(design)
# Estimate dispersion for genes with Bayesian Shrinkage
cat(">> Estimating dispersion...")
y <- estimateDisp(y,design)
# Fit the model
cat(">> Fitting GLM...")
fit.glm <- glmQLFit(y,design)
combs <- combn(colnames(design), 2)
View(combs)
edgeR::edgeRUsersGuide(
)
qlf <- glmQLFTest(fit, coef=4)
qlf <- glmQLFTest(fit.glm, coef=4)
qlf <- glmQLFTest(fit.glm, coef=1)
View(qlf)
qlf <- glmQLFTest(fit.glm, coef=2)
View(qlf)
combs
source('~/Dropbox (JAX)/cinaR/cinaR/R/cinaR.R')
load("data/atac_seq_consensus_bm.Rdata")
consensus.peaks <- bed
# collapse chr, start, end and make them rownames
cp.rownames <- apply(consensus.peaks[,1:3], 1, function(x){paste0(trimws(x), collapse = "_")})
cp <- consensus.peaks[,-c(1:3)]
rownames(cp) <- cp.rownames
# filter low expressed peaks
cp.filtered <- filterConsensus(cp, library.threshold = library.threshold, cpm.threshold = cpm.threshold)
library.threshold = 2
DA.choice = 1, norm.method = "cpm", filter.method = "custom",
library.threshold = 2, cpm.threshold = 1, TSS.threshold = 50e3,
show.annotation.pie = F, reference.genome = NULL
DA.choice = 1
norm.method = "cpm"
filter.method = "custom"
library.threshold = 2
cpm.threshold = 1
TSS.threshold = 50e3
show.annotation.pie = F
reference.genome = NULL
# filter low expressed peaks
cp.filtered <- filterConsensus(cp, library.threshold = library.threshold, cpm.threshold = cpm.threshold)
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
reference.genome = NULL
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
require(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
annotatePeaks <-
function(cp, reference.genome, show.annotation.pie = F){
require(ChIPseeker)
require(GenomicRanges)
bed <- as.data.frame(do.call(rbind, strsplit(rownames(cp), "_", fixed = T)))
colnames(bed) <- c("CHR", "Start", "End")
bed.GRanges <- GRanges(bed)
if (is.null(reference.genome)){
warning("'reference.genome' is not set, therefore hg38 will be used!")
}
if(reference.genome == "hg38" | is.null(reference.genome)){
require(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
} else if (reference.genome == "hg19"){
require(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else if (reference.genome == "mm10"){
require(TxDb.Mmusculus.UCSC.mm10.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
} else {
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# annotate peaks
annoPeaks <- annotatePeak(bed.GRanges, TxDb = txdb)
if(show.annotation.pie){
plotAnnoPie(annoPeaks)
}
annoPeaks.anno <- annoPeaks@anno
entrezids <- unique(annoPeaks.anno$geneId)
require(annotables)
if(reference.genome == "hg38"){
genome <- grch38
} else if (reference.genome == "hg19"){
genome <- grch37
} else if (reference.genome == "mm10"){
genome <- grcm38
} else { # safe than sorry!
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# entrez to gene name mapping
entrez2gene <- subset(genome, genome$entrez %in% entrezids, select = c(entrez, symbol))
# Match to each annotation dataframe
m <- match(annoPeaks.anno$geneId, entrez2gene$entrez)
annoPeaks.anno$gene_name <- entrez2gene$symbol[m]
return(cbind(annoPeaks.anno, cp))
}
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
reference.genome == "hg38" | is.null(reference.genome
)
reference.genome == "hg38" || is.null(reference.genome)
annotatePeaks <-
function(cp, reference.genome, show.annotation.pie = F){
require(ChIPseeker)
require(GenomicRanges)
bed <- as.data.frame(do.call(rbind, strsplit(rownames(cp), "_", fixed = T)))
colnames(bed) <- c("CHR", "Start", "End")
bed.GRanges <- GRanges(bed)
if (is.null(reference.genome)){
warning("'reference.genome' is not set, therefore hg38 will be used!")
}
if(reference.genome == "hg38" || is.null(reference.genome)){
require(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
} else if (reference.genome == "hg19"){
require(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else if (reference.genome == "mm10"){
require(TxDb.Mmusculus.UCSC.mm10.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
} else {
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# annotate peaks
annoPeaks <- annotatePeak(bed.GRanges, TxDb = txdb)
if(show.annotation.pie){
plotAnnoPie(annoPeaks)
}
annoPeaks.anno <- annoPeaks@anno
entrezids <- unique(annoPeaks.anno$geneId)
require(annotables)
if(reference.genome == "hg38"){
genome <- grch38
} else if (reference.genome == "hg19"){
genome <- grch37
} else if (reference.genome == "mm10"){
genome <- grcm38
} else { # safe than sorry!
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# entrez to gene name mapping
entrez2gene <- subset(genome, genome$entrez %in% entrezids, select = c(entrez, symbol))
# Match to each annotation dataframe
m <- match(annoPeaks.anno$geneId, entrez2gene$entrez)
annoPeaks.anno$gene_name <- entrez2gene$symbol[m]
return(cbind(annoPeaks.anno, cp))
}
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
load("/Users/karako/Dropbox (JAX)/cinaR/cinaR/data/atac_seq_consensus_bm.Rda")
load("/Users/karako/Dropbox (JAX)/cinaR/cinaR/data/atac_seq_consensus_bm.Rda")
View(bed)
library(cinaR)
cinaR::bed
load(atac_seq_consensus_bm)
load(atac_seq_consensus_bm.rda)
cinaR::bed
library(cinaR)
data(bed)
data("atac_seq_consensus_bm")
bed
DA.choice = 1
norm.method = "cpm"
library.threshold = 2
cpm.threshold = 1
TSS.threshold = 50e3
filter.method = "custom"
show.annotation.pie = F
reference.genome = NULL
consensus.peaks <- be
consensus.peaks <- bed
# collapse chr, start, end and make them rownames
cp.rownames <- apply(consensus.peaks[,1:3], 1, function(x){paste0(trimws(x), collapse = "_")})
cp <- consensus.peaks[,-c(1:3)]
rownames(cp) <- cp.rownames
# filter low expressed peaks
cp.filtered <- filterConsensus(cp, library.threshold = library.threshold, cpm.threshold = cpm.threshold)
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie)
reference.genome
library(cinaR)
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie = show.annotation.pie)
annotatePeaks <-
function(cp, reference.genome, show.annotation.pie = F){
bed <- as.data.frame(do.call(rbind, strsplit(rownames(cp), "_", fixed = T)))
colnames(bed) <- c("CHR", "Start", "End")
bed.GRanges <- GRanges(bed)
if (is.null(reference.genome)){
warning("'reference.genome' is not set, therefore hg38 will be used!")
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
} else if(reference.genome == "hg38"){
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
} else if (reference.genome == "hg19"){
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else if (reference.genome == "mm10"){
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
} else {
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# annotate peaks
annoPeaks <- annotatePeak(bed.GRanges, TxDb = txdb)
if(show.annotation.pie){
plotAnnoPie(annoPeaks)
}
annoPeaks.anno <- annoPeaks@anno
entrezids <- unique(annoPeaks.anno$geneId)
if(reference.genome == "hg38" || is.null(reference.genome)){
genome <- grch38
} else if (reference.genome == "hg19"){
genome <- grch37
} else if (reference.genome == "mm10"){
genome <- grcm38
} else { # safe than sorry!
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# entrez to gene name mapping
entrez2gene <- subset(genome, genome$entrez %in% entrezids, select = c(entrez, symbol))
# Match to each annotation dataframe
m <- match(annoPeaks.anno$geneId, entrez2gene$entrez)
annoPeaks.anno$gene_name <- entrez2gene$symbol[m]
return(cbind(annoPeaks.anno, cp))
}
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie = show.annotation.pie)
reference.genome
reference.genome = "mm10"
# annotate the peaks to the closest TSS
cp.filtered.annotated <- annotatePeaks(cp.filtered,
reference.genome = reference.genome,
show.annotation.pie = show.annotation.pie)
library(cinaR)
library(cinaR)
force(annotatePeaks)
devtools::load_all(".")
annotatePeaks <-
function(cp,
reference.genome,
show.annotation.pie = F) {
library(annotables, verbose = F)
library(ChIPseeker, verbose = F)
bed <- as.data.frame(do.call(rbind, strsplit(rownames(cp), "_", fixed = T)))
colnames(bed) <- c("CHR", "Start", "End")
bed.GRanges <- GRanges(bed)
if (is.null(reference.genome)) {
warning("'reference.genome' is not set, therefore hg38 will be used!")
library(TxDb.Hsapiens.UCSC.hg38.knownGene, verbose = F)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
genome <- grch38
} else if (reference.genome == "hg38") {
library(TxDb.Hsapiens.UCSC.hg38.knownGene, verbose = F)
library()
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
genome <- grch38
} else if (reference.genome == "hg19") {
library(TxDb.Hsapiens.UCSC.hg19.knownGene, verbose = F)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
genome <- grch37
} else if (reference.genome == "mm10") {
library(TxDb.Mmusculus.UCSC.mm10.knownGene, verbose = F)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
genome <- grcm38
} else {
stop ("reference.genome should be 'hg38', 'hg19' or 'mm10'")
}
# annotate peaks
annoPeaks <- annotatePeak(bed.GRanges, TxDb = txdb)
if (show.annotation.pie) {
plotAnnoPie(annoPeaks)
}
annoPeaks.anno <- annoPeaks@anno
entrezids <- unique(annoPeaks.anno$geneId)
# entrez to gene name mapping
entrez2gene <-
subset(genome, genome$entrez %in% entrezids, select = c(entrez, symbol))
# Match to each annotation dataframe
m <- match(annoPeaks.anno$geneId, entrez2gene$entrez)
annoPeaks.anno$gene_name <- entrez2gene$symbol[m]
return(cbind(annoPeaks.anno, cp))
}
library(cinaR)
library(cinaR)
library(cinaR)
View(annotatePeaks)
force(filterConsensus)
library(cinaR)
library(edgeR)
library(cinaR)
library(cinaR)
library(cinaR)
data("atac_seq_consensus_bm")
library(cinaR)
library(cinaR)
document()
library(devtools)
document()
library(cinaR)
document()
library(devtools)
document
document()
document()
library(cinaR)
library(cinaR)
data("atac_seq_consensus_bm")
bed
save(bed, file = "data/atac_seq_consensus_bm.rda", compress = 'xz')
document()
library(cinaR)
library(cinaR)
document()
library(cinaR)
